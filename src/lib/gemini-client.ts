import { validateFile } from './file-utils';

// We'll create the API key service instance later
interface ApiKeyService {
  getApiKey(): Promise<string | null>;
}

// Gemini API types
export interface GeminiImageGenerationResponse {
  candidates: Array<{
    content: {
      parts: Array<{
        text?: string;
        inlineData?: {
          mimeType: string;
          data: string; // base64 encoded
        };
      }>;
    };
    finishReason: string;
  }>;
  usageMetadata?: {
    promptTokenCount: number;
    candidatesTokenCount: number;
    totalTokenCount: number;
  };
}

export interface GeminiError {
  error: {
    code: number;
    message: string;
    status: string;
  };
}

export interface ImageTransformationRequest {
  image: File;
  style: string;
  prompt?: string;
}

export interface ImageTransformationResult {
  success: boolean;
  transformedImage?: string; // base64 data URL
  originalPrompt?: string;
  generatedText?: string;
  error?: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
}

export class GeminiClient {
  private readonly API_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta';
  private readonly IMAGE_MODEL = 'gemini-2.0-flash-preview-image-generation';
  private readonly TEXT_MODEL = 'gemini-2.0-flash';
  private readonly MAX_RETRIES = 3;
  private readonly TIMEOUT_MS = 30000; // 30 seconds

  constructor(private apiKeyService: ApiKeyService) {}

  /**
   * Transform an image using Gemini 2.0 Flash image generation
   */
  async transformImage(request: ImageTransformationRequest): Promise<ImageTransformationResult> {
    try {
      // Validate the input image
      const validation = validateFile(request.image);
      if (!validation.isValid) {
        return {
          success: false,
          error: `Invalid image: ${validation.error}`
        };
      }

      // Get API key
      const apiKey = await this.apiKeyService.getApiKey();
      if (!apiKey) {
        return {
          success: false,
          error: 'No API key available. Please configure your Gemini API key in settings.'
        };
      }

      // Convert image to base64
      const imageBase64 = await this.fileToBase64(request.image);
      
      // Build the style transformation prompt
      const transformationPrompt = this.buildStylePrompt(request.style, request.prompt);

      // Create the request payload
      const payload = {
        contents: [
          {
            parts: [
              {
                text: transformationPrompt
              },
              {
                inlineData: {
                  mimeType: request.image.type,
                  data: imageBase64
                }
              }
            ]
          }
        ],
        generationConfig: {
          responseModalities: ["TEXT", "IMAGE"],
          temperature: 0.7,
          topP: 0.8,
          topK: 40
        }
      };

      // Make the API request with retry logic
      const response = await this.makeRequestWithRetry(
        `${this.API_BASE_URL}/models/${this.IMAGE_MODEL}:generateContent`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-goog-api-key': apiKey
          },
          body: JSON.stringify(payload)
        }
      );

      if (!response.ok) {
        const errorData = await response.json() as GeminiError;
        return {
          success: false,
          error: `API Error: ${errorData.error?.message || 'Unknown error'}`
        };
      }

      const data = await response.json() as GeminiImageGenerationResponse;
      
      if (!data.candidates?.[0]?.content?.parts) {
        return {
          success: false,
          error: 'No content generated by the model'
        };
      }

      // Extract generated content
      let transformedImage: string | undefined;
      let generatedText: string | undefined;

      for (const part of data.candidates[0].content.parts) {
        if (part.inlineData?.data) {
          // Convert base64 to data URL
          transformedImage = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
        }
        if (part.text) {
          generatedText = part.text;
        }
      }

      if (!transformedImage) {
        return {
          success: false,
          error: 'No image generated by the model'
        };
      }

      return {
        success: true,
        transformedImage,
        originalPrompt: transformationPrompt,
        generatedText,
        usage: data.usageMetadata ? {
          promptTokens: data.usageMetadata.promptTokenCount,
          completionTokens: data.usageMetadata.candidatesTokenCount,
          totalTokens: data.usageMetadata.totalTokenCount
        } : undefined
      };

    } catch (error) {
      console.error('Image transformation error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'An unknown error occurred'
      };
    }
  }

  /**
   * Generate text using Gemini 2.0 Flash
   */
  async generateText(prompt: string): Promise<{ success: boolean; text?: string; error?: string }> {
    try {
      const apiKey = await this.apiKeyService.getApiKey();
      if (!apiKey) {
        return {
          success: false,
          error: 'No API key available'
        };
      }

      const payload = {
        contents: [
          {
            parts: [{ text: prompt }]
          }
        ],
        generationConfig: {
          temperature: 0.7,
          topP: 0.8,
          topK: 40
        }
      };

      const response = await this.makeRequestWithRetry(
        `${this.API_BASE_URL}/models/${this.TEXT_MODEL}:generateContent`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-goog-api-key': apiKey
          },
          body: JSON.stringify(payload)
        }
      );

      if (!response.ok) {
        const errorData = await response.json() as GeminiError;
        return {
          success: false,
          error: errorData.error?.message || 'Unknown error'
        };
      }

      const data = await response.json();
      const text = data.candidates?.[0]?.content?.parts?.[0]?.text;

      if (!text) {
        return {
          success: false,
          error: 'No text generated'
        };
      }

      return {
        success: true,
        text
      };

    } catch (error) {
      console.error('Text generation error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'An unknown error occurred'
      };
    }
  }

  /**
   * Build a style transformation prompt
   */
  private buildStylePrompt(style: string, customPrompt?: string): string {
    const basePrompt = `Transform this image into ${style} style.`;
    
    const styleGuides: Record<string, string> = {
      'Van Gogh': 'Apply Van Gogh\'s distinctive swirling brushstrokes, bold impasto technique, and vibrant colors. Focus on emotional expression through movement and color.',
      'Picasso': 'Transform into Picasso\'s cubist style with geometric shapes, fragmented forms, and multiple perspectives. Use bold lines and abstract representation.',
      'Monet': 'Apply Monet\'s impressionist technique with soft, blended brushstrokes, focus on light and atmosphere, and gentle color transitions.',
      'Pop Art': 'Transform into pop art style with bold, vibrant colors, high contrast, and comic book-like appearance. Add halftone patterns if appropriate.',
      'Watercolor': 'Convert to watercolor painting style with transparent washes, wet-on-wet effects, and soft, flowing color blends.',
      'Oil Painting': 'Transform into oil painting style with rich, thick brushstrokes, deep colors, and classical painting techniques.',
      'Anime': 'Convert to anime/manga style with large expressive eyes, clean lines, cell-shading, and vibrant colors.',
      'Cartoon': 'Transform into cartoon style with simplified forms, bold outlines, bright colors, and exaggerated features.',
      'Realistic': 'Enhance the image while maintaining photorealistic quality, improving lighting, composition, and overall visual appeal.',
      'Abstract': 'Transform into abstract art with non-representational forms, bold colors, and artistic interpretation of the subject.'
    };

    const styleGuide = styleGuides[style] || `Apply ${style} artistic style`;
    
    let fullPrompt = `${basePrompt} ${styleGuide}`;
    
    if (customPrompt) {
      fullPrompt += ` Additional instructions: ${customPrompt}`;
    }
    
    fullPrompt += ' Maintain the core subject and composition while applying the artistic transformation. Generate a high-quality artistic interpretation.';
    
    return fullPrompt;
  }

  /**
   * Convert file to base64 string
   */
  private async fileToBase64(file: File): Promise<string> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const result = reader.result as string;
        // Remove data URL prefix to get pure base64
        const base64 = result.split(',')[1];
        resolve(base64);
      };
      reader.onerror = () => reject(reader.error);
      reader.readAsDataURL(file);
    });
  }

  /**
   * Make HTTP request with retry logic
   */
  private async makeRequestWithRetry(url: string, options: RequestInit): Promise<Response> {
    let lastError: Error | null = null;

    for (let attempt = 1; attempt <= this.MAX_RETRIES; attempt++) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.TIMEOUT_MS);

        const response = await fetch(url, {
          ...options,
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        // If rate limited, wait and retry
        if (response.status === 429) {
          const retryAfter = response.headers.get('retry-after');
          const waitTime = retryAfter ? parseInt(retryAfter) * 1000 : Math.min(1000 * Math.pow(2, attempt), 10000);
          
          if (attempt < this.MAX_RETRIES) {
            await new Promise(resolve => setTimeout(resolve, waitTime));
            continue;
          }
        }

        return response;

      } catch (error) {
        lastError = error instanceof Error ? error : new Error('Unknown error');
        
        if (attempt < this.MAX_RETRIES) {
          // Exponential backoff
          const waitTime = Math.min(1000 * Math.pow(2, attempt), 10000);
          await new Promise(resolve => setTimeout(resolve, waitTime));
          continue;
        }
      }
    }

    throw lastError || new Error('Max retries exceeded');
  }

  /**
   * Test API connection
   */
  async testConnection(): Promise<{ success: boolean; error?: string }> {
    try {
      const result = await this.generateText('Hello, this is a test message.');
      return {
        success: result.success,
        error: result.error
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Connection test failed'
      };
    }
  }
} 